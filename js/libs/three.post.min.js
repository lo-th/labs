'use strict';var THREE;
THREE.EffectComposer=function(a,c){this.renderer=a;void 0===c&&(c=new THREE.WebGLRenderTarget(window.innerWidth||1,window.innerHeight||1,{minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBFormat,stencilBuffer:!1}));this.renderTarget1=c;this.renderTarget2=c.clone();this.writeBuffer=this.renderTarget1;this.readBuffer=this.renderTarget2;this.passes=[];void 0===THREE.CopyShader&&console.error("THREE.EffectComposer relies on THREE.CopyShader");this.copyPass=new THREE.ShaderPass(THREE.CopyShader)};
THREE.EffectComposer.prototype={swapBuffers:function(){var a=this.readBuffer;this.readBuffer=this.writeBuffer;this.writeBuffer=a},addPass:function(a){this.passes.push(a)},insertPass:function(a,c){this.passes.splice(c,0,a)},render:function(a){this.writeBuffer=this.renderTarget1;this.readBuffer=this.renderTarget2;var c=!1,d,b,e=this.passes.length;for(b=0;b<e;b++)if(d=this.passes[b],d.enabled){d.render(this.renderer,this.writeBuffer,this.readBuffer,a,c);if(d.needsSwap){if(c){var f=this.renderer.context;
f.stencilFunc(f.NOTEQUAL,1,4294967295);this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,a);f.stencilFunc(f.EQUAL,1,4294967295)}this.swapBuffers()}d instanceof THREE.MaskPass?c=!0:d instanceof THREE.ClearMaskPass&&(c=!1)}},reset:function(a){void 0===a&&(a=this.renderTarget1.clone(),a.width=window.innerWidth,a.height=window.innerHeight);this.renderTarget1=a;this.renderTarget2=a.clone();this.writeBuffer=this.renderTarget1;this.readBuffer=this.renderTarget2},setSize:function(a,c){var d=
this.renderTarget1.clone();d.width=a;d.height=c;this.reset(d)}};THREE.MaskPass=function(a,c){this.scene=a;this.camera=c;this.clear=this.enabled=!0;this.inverse=this.needsSwap=!1};
THREE.MaskPass.prototype={render:function(a,c,d,b){b=a.context;b.colorMask(!1,!1,!1,!1);b.depthMask(!1);var e,f;this.inverse?(e=0,f=1):(e=1,f=0);b.enable(b.STENCIL_TEST);b.stencilOp(b.REPLACE,b.REPLACE,b.REPLACE);b.stencilFunc(b.ALWAYS,e,4294967295);b.clearStencil(f);a.render(this.scene,this.camera,d,this.clear);a.render(this.scene,this.camera,c,this.clear);b.colorMask(!0,!0,!0,!0);b.depthMask(!0);b.stencilFunc(b.EQUAL,1,4294967295);b.stencilOp(b.KEEP,b.KEEP,b.KEEP)}};
THREE.ClearMaskPass=function(){this.enabled=!0};THREE.ClearMaskPass.prototype={render:function(a,c,d,b){a=a.context;a.disable(a.STENCIL_TEST)}};THREE.RenderPass=function(a,c,d,b,e){this.scene=a;this.camera=c;this.overrideMaterial=d;this.clearColor=b;this.clearAlpha=void 0!==e?e:1;this.oldClearColor=new THREE.Color;this.oldClearAlpha=1;this.clear=this.enabled=!0;this.needsSwap=!1};
THREE.RenderPass.prototype={render:function(a,c,d,b){this.scene.overrideMaterial=this.overrideMaterial;this.clearColor&&(this.oldClearColor.copy(a.getClearColor()),this.oldClearAlpha=a.getClearAlpha(),a.setClearColor(this.clearColor,this.clearAlpha));a.render(this.scene,this.camera,d,this.clear);this.clearColor&&a.setClearColor(this.oldClearColor,this.oldClearAlpha);this.scene.overrideMaterial=null}};
THREE.ShaderPass=function(a,c){this.textureID=void 0!==c?c:"tDiffuse";this.uniforms=THREE.UniformsUtils.clone(a.uniforms);this.material=new THREE.ShaderMaterial({defines:a.defines||{},uniforms:this.uniforms,vertexShader:a.vertexShader,fragmentShader:a.fragmentShader});this.renderToScreen=!1;this.needsSwap=this.enabled=!0;this.clear=!1;this.camera=new THREE.OrthographicCamera(-1,1,1,-1,0,1);this.scene=new THREE.Scene;this.quad=new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2),null);this.scene.add(this.quad)};
THREE.ShaderPass.prototype={render:function(a,c,d,b){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=d);this.quad.material=this.material;this.renderToScreen?a.render(this.scene,this.camera):a.render(this.scene,this.camera,c,this.clear)}};THREE.CopyShader={uniforms:{tDiffuse:{type:"t",value:null},opacity:{type:"f",value:1}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform float opacity;\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\nvec4 texel = texture2D( tDiffuse, vUv );\ngl_FragColor = opacity * texel;\n}"};
THREE.SSAOShader={uniforms:{tDiffuse:{type:"t",value:null},tDepth:{type:"t",value:null},size:{type:"v2",value:new THREE.Vector2(512,512)},cameraNear:{type:"f",value:1},cameraFar:{type:"f",value:100},onlyAO:{type:"i",value:0},aoClamp:{type:"f",value:0.5},lumInfluence:{type:"f",value:0.5}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform float cameraNear;\nuniform float cameraFar;\nuniform bool onlyAO;\nuniform vec2 size;\nuniform float aoClamp;\nuniform float lumInfluence;\nuniform sampler2D tDiffuse;\nuniform sampler2D tDepth;\nvarying vec2 vUv;\n#define DL 2.399963229728653\n#define EULER 2.718281828459045\nfloat width = size.x;\nfloat height = size.y;\nfloat cameraFarPlusNear = cameraFar + cameraNear;\nfloat cameraFarMinusNear = cameraFar - cameraNear;\nfloat cameraCoef = 2.0 * cameraNear;\nconst int samples = 8;\nconst float radius = 5.0;\nconst bool useNoise = false;\nconst float noiseAmount = 0.0003;\nconst float diffArea = 0.4;\nconst float gDisplace = 0.4;\nfloat unpackDepth( const in vec4 rgba_depth ) {\nconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\nfloat depth = dot( rgba_depth, bit_shift );\nreturn depth;\n}\nvec2 rand( const vec2 coord ) {\nvec2 noise;\nif ( useNoise ) {\nfloat nx = dot ( coord, vec2( 12.9898, 78.233 ) );\nfloat ny = dot ( coord, vec2( 12.9898, 78.233 ) * 2.0 );\nnoise = clamp( fract ( 43758.5453 * sin( vec2( nx, ny ) ) ), 0.0, 1.0 );\n} else {\nfloat ff = fract( 1.0 - coord.s * ( width / 2.0 ) );\nfloat gg = fract( coord.t * ( height / 2.0 ) );\nnoise = vec2( 0.25, 0.75 ) * vec2( ff ) + vec2( 0.75, 0.25 ) * gg;\n}\nreturn ( noise * 2.0  - 1.0 ) * noiseAmount;\n}\nfloat readDepth( const in vec2 coord ) {\nreturn cameraCoef / ( cameraFarPlusNear - unpackDepth( texture2D( tDepth, coord ) ) * cameraFarMinusNear );\n}\nfloat compareDepths( const in float depth1, const in float depth2, inout int far ) {\nfloat garea = 2.0;\nfloat diff = ( depth1 - depth2 ) * 100.0;\nif ( diff < gDisplace ) {\ngarea = diffArea;\n} else {\nfar = 1;\n}\nfloat dd = diff - gDisplace;\nfloat gauss = pow( EULER, -2.0 * dd * dd / ( garea * garea ) );\nreturn gauss;\n}\nfloat calcAO( float depth, float dw, float dh ) {\nfloat dd = radius - depth * radius;\nvec2 vv = vec2( dw, dh );\nvec2 coord1 = vUv + dd * vv;\nvec2 coord2 = vUv - dd * vv;\nfloat temp1 = 0.0;\nfloat temp2 = 0.0;\nint far = 0;\ntemp1 = compareDepths( depth, readDepth( coord1 ), far );\nif ( far > 0 ) {\ntemp2 = compareDepths( readDepth( coord2 ), depth, far );\ntemp1 += ( 1.0 - temp1 ) * temp2;\n}\nreturn temp1;\n}\nvoid main() {\nvec2 noise = rand( vUv );\nfloat depth = readDepth( vUv );\nfloat tt = clamp( depth, aoClamp, 1.0 );\nfloat w = ( 1.0 / width )  / tt + ( noise.x * ( 1.0 - noise.x ) );\nfloat h = ( 1.0 / height ) / tt + ( noise.y * ( 1.0 - noise.y ) );\nfloat ao = 0.0;\nfloat dz = 1.0 / float( samples );\nfloat z = 1.0 - dz / 2.0;\nfloat l = 0.0;\nfor ( int i = 0; i <= samples; i ++ ) {\nfloat r = sqrt( 1.0 - z );\nfloat pw = cos( l ) * r;\nfloat ph = sin( l ) * r;\nao += calcAO( depth, pw * w, ph * h );\nz = z - dz;\nl = l + DL;\n}\nao /= float( samples );\nao = 1.0 - ao;\nvec3 color = texture2D( tDiffuse, vUv ).rgb;\nvec3 lumcoeff = vec3( 0.299, 0.587, 0.114 );\nfloat lum = dot( color.rgb, lumcoeff );\nvec3 luminance = vec3( lum );\nvec3 final = vec3( color * mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );\nif ( onlyAO ) {\nfinal = vec3( mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );\n}\ngl_FragColor = vec4( final, 1.0 );\n}"};
THREE.FXAAShader={uniforms:{tDiffuse:{type:"t",value:null},resolution:{type:"v2",value:new THREE.Vector2(1/1024,1/512)}},vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D tDiffuse;\nuniform vec2 resolution;\nvarying vec2 vUv;\n#define FXAA_REDUCE_MIN   (1.0/128.0)\n#define FXAA_REDUCE_MUL   (1.0/8.0)\n#define FXAA_SPAN_MAX     8.0\nvoid main() {\nvec3 rgbNW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, -1.0 ) ) * resolution ).xyz;\nvec3 rgbNE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, -1.0 ) ) * resolution ).xyz;\nvec3 rgbSW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, 1.0 ) ) * resolution ).xyz;\nvec3 rgbSE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, 1.0 ) ) * resolution ).xyz;\nvec4 rgbaM  = texture2D( tDiffuse,  gl_FragCoord.xy  * resolution );\nvec3 rgbM  = rgbaM.xyz;\nfloat opacity  = rgbaM.w;\nvec3 luma = vec3( 0.299, 0.587, 0.114 );\nfloat lumaNW = dot( rgbNW, luma );\nfloat lumaNE = dot( rgbNE, luma );\nfloat lumaSW = dot( rgbSW, luma );\nfloat lumaSE = dot( rgbSE, luma );\nfloat lumaM  = dot( rgbM,  luma );\nfloat lumaMin = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );\nfloat lumaMax = max( lumaM, max( max( lumaNW, lumaNE) , max( lumaSW, lumaSE ) ) );\nvec2 dir;\ndir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\ndir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\nfloat dirReduce = max( ( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * FXAA_REDUCE_MUL ), FXAA_REDUCE_MIN );\nfloat rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );\ndir = min( vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\nmax( vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\ndir * rcpDirMin)) * resolution;\nvec3 rgbA = 0.5 * (\ntexture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * ( 1.0 / 3.0 - 0.5 ) ).xyz +\ntexture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * ( 2.0 / 3.0 - 0.5 ) ).xyz );\nvec3 rgbB = rgbA * 0.5 + 0.25 * (\ntexture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * -0.5 ).xyz +\ntexture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * 0.5 ).xyz );\nfloat lumaB = dot( rgbB, luma );\nif ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) ) {\ngl_FragColor = vec4( rgbA, opacity );\n} else {\ngl_FragColor = vec4( rgbB, opacity );\n}\n}"};
THREE.DepthDef={uniforms:{tdeep:{type:"t",value:null},offset:{type:"v2",value:new THREE.Vector2},range:{type:"v2",value:new THREE.Vector2},uDisplacementBias:{type:"f",value:-3},uDisplacementScale:{type:"f",value:6}},vertexShader:["uniform sampler2D tdeep;\nuniform float uDisplacementScale;\nuniform float uDisplacementBias;\nuniform vec2 offset;\nuniform vec2 range;\nvarying vec2 vUv2;",THREE.ShaderChunk.morphtarget_pars_vertex,THREE.ShaderChunk.skinning_pars_vertex,THREE.ShaderChunk.logdepthbuf_pars_vertex,
"void main() {",THREE.ShaderChunk.skinbase_vertex,THREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.skinning_vertex,THREE.ShaderChunk.default_vertex,"#ifdef USE_SKINNING\ngl_Position = projectionMatrix * mvPosition;\n#else\nvUv2 = (vec2(position.x, position.z)+offset)/range;\nvUv2.y = 1.0-vUv2.y;\nvec3 dv = texture2D( tdeep, vUv2 ).xyz;\nfloat df = (uDisplacementScale * dv.x) + uDisplacementBias;\nvec3 displacedPosition = position;\ndisplacedPosition.y += df;\ngl_Position = projectionMatrix * modelViewMatrix * vec4(displacedPosition,1.0);\n#endif",
THREE.ShaderChunk.logdepthbuf_vertex,"}"].join("\n"),fragmentShader:[THREE.ShaderChunk.logdepthbuf_pars_fragment,"vec4 pack_depth( const in float depth ) {\n\tconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n\tconst vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n\tvec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\n\tres -= res.xxyz * bit_mask;\n\treturn res;\n}\nvoid main() {",THREE.ShaderChunk.logdepthbuf_fragment,
"\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tgl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );\n\t#else\n\t\tgl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\n\t#endif\n}"].join("\n")};
THREE.DepthDef2={uniforms:{},vertexShader:[THREE.ShaderChunk.morphtarget_pars_vertex,THREE.ShaderChunk.skinning_pars_vertex,THREE.ShaderChunk.logdepthbuf_pars_vertex,"void main() {",THREE.ShaderChunk.skinbase_vertex,THREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.skinning_vertex,THREE.ShaderChunk.default_vertex,THREE.ShaderChunk.logdepthbuf_vertex,"}"].join("\n"),fragmentShader:[THREE.ShaderChunk.logdepthbuf_pars_fragment,"vec4 pack_depth( const in float depth ) {\n\tconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n\tconst vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n\tvec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\n\tres -= res.xxyz * bit_mask;\n\treturn res;\n}\nvoid main() {",
THREE.ShaderChunk.logdepthbuf_fragment,"\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tgl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );\n\t#else\n\t\tgl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\n\t#endif\n}"].join("\n")};
